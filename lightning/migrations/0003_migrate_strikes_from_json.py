# Generated by Django X.Y on YYYY-MM-DD HH:MM
from django.db import migrations
import datetime # Import datetime

def forwards_func(apps, schema_editor):
    """
    Reads strike data from NexStormData.json_data['StrikeData']
    and creates corresponding Strike model instances.
    """
    NexStormData = apps.get_model('lightning', 'NexStormData')
    Strike = apps.get_model('lightning', 'Strike')
    print("\nStarting migration of strikes from JSON...") # Progress message

    # Use iterator() for memory efficiency on large datasets
    strike_objects_to_create = []
    batch_size = 500 # Process in batches to manage memory

    for nexstorm_entry in NexStormData.objects.all().iterator():
        try:
            entry_json = nexstorm_entry.json_data
            if not isinstance(entry_json, dict):
                print(f"  Skipping NexStormData {nexstorm_entry.id}: json_data is not a dictionary.")
                continue

            strike_data_list = entry_json.get('StrikeData', [])
            if not isinstance(strike_data_list, list):
                 print(f"  Skipping NexStormData {nexstorm_entry.id}: StrikeData is not a list.")
                 continue

            main_timestamp_epoch = entry_json.get('TimestampEpoch', 0)
            main_timestamp_sec = main_timestamp_epoch / 1000 if main_timestamp_epoch else 0


            for strike_json in strike_data_list:
                 if not isinstance(strike_json, dict):
                     print(f"  Skipping invalid strike format in NexStormData {nexstorm_entry.id}: {strike_json}")
                     continue

                 try:
                     strike_millis = strike_json.get('millis')
                     if strike_millis is None or strike_millis <= 1000000:
                         strike_dt = datetime.datetime.fromtimestamp(main_timestamp_sec)
                     else:
                         strike_dt = datetime.datetime.fromtimestamp(strike_millis / 1000)

                     # Basic validation for coordinates
                     lat_val = strike_json.get('lat')
                     lon_val = strike_json.get('lon')
                     lat = float(lat_val) if lat_val is not None else None
                     lon = float(lon_val) if lon_val is not None else None

                     strike_type = strike_json.get('type')
                     st_type = int(strike_type) if strike_type is not None else None

                     # Create Strike object (but don't save yet for batching)
                     strike_objects_to_create.append(
                         Strike(
                             nexstorm_data=nexstorm_entry,
                             timestamp=strike_dt,
                             latitude=lat,
                             longitude=lon,
                             strike_type=st_type
                         )
                     )

                     # Bulk create when batch size is reached
                     if len(strike_objects_to_create) >= batch_size:
                         Strike.objects.bulk_create(strike_objects_to_create)
                         print(f"  Created {len(strike_objects_to_create)} strikes...")
                         strike_objects_to_create = [] # Reset batch

                 except (ValueError, TypeError, AttributeError) as strike_e:
                     print(f"  Skipping bad strike record within NexStormData {nexstorm_entry.id}. Error: {strike_e}. Strike: {strike_json}")
                     continue # Skip this strike

        except Exception as entry_e:
            print(f"  Error processing NexStormData entry {nexstorm_entry.id}: {entry_e}")
            continue # Skip this whole entry

    # Create any remaining objects in the last batch
    if strike_objects_to_create:
         Strike.objects.bulk_create(strike_objects_to_create)
         print(f"  Created final {len(strike_objects_to_create)} strikes.")

    print("Finished migrating strikes.")


def reverse_func(apps, schema_editor):
    """
    Deletes all Strike objects created by the forwards migration.
    (Allows rolling back the migration if needed).
    """
    Strike = apps.get_model('lightning', 'Strike')
    print("\nDeleting migrated Strike objects...")
    Strike.objects.all().delete()
    print("Finished deleting strikes.")


class Migration(migrations.Migration):

    dependencies = [
        # Add dependency on the previous migration (the one that created Strike model)
        ('lightning', '0001_initial'), 
    ]

    operations = [
        migrations.RunPython(forwards_func, reverse_func),
    ]